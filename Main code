import numpy as np
from scipy.constants import epsilon_0, elementary_charge, pi, Boltzmann
import plotly.graph_objs as go
from matplotlib import pyplot as plt
import time
import os
import itertools


print("Molecule? BeH2,   CO2,   H2O,   BF3,   NH3,   ClF3 (CASE SENSITIVE)")
partname = str(input())

# LINEAR

if (partname == "BeH2"):
    energy = np.array([
        elementary_charge * 4,
        elementary_charge * 1,
        elementary_charge * 1,
    ] + [-elementary_charge] * 6 )
    predicted = 180
    Initial_Temp = 200

if (partname == "CO2"):
    energy = np.array([
        elementary_charge * 6,
        elementary_charge * 8,
        elementary_charge * 8,
    ] + [-elementary_charge] *14 + [-elementary_charge * 2] * 4)
    predicted = 180
    Initial_Temp = 700

# BENT

if (partname == "H2O"):
    energy = np.array([
        elementary_charge * 8,
        elementary_charge,
        elementary_charge,
    ] + [-elementary_charge] * 6 + [-elementary_charge * 2] * 2)
    predicted = 104.5
    Initial_Temp = 400

#TRIGONAL

if (partname == "BF3"):
    energy = np.array([
        elementary_charge * 5,
        elementary_charge * 9,
        elementary_charge * 9,
        elementary_charge * 9,
    ] + [-elementary_charge] * 14 + [-elementary_charge * 2] * 9)
    predicted = 120
    Initial_Temp = 900

if (partname == "NH3"):
    energy = np.array([
        elementary_charge * 7,
        elementary_charge * 1,
        elementary_charge * 1,
        elementary_charge * 1,
    ] + [-elementary_charge] * 8 + [-elementary_charge * 2] * 1)
    predicted = 107.8
    Initial_Temp = 400

# T-SHAPED

if (partname == "ClF3"):
    energy = np.array([
        elementary_charge * 17,
        elementary_charge * 9,
        elementary_charge * 9,
        elementary_charge * 9,
    ] + [-elementary_charge] * 22 + [-elementary_charge * 2] * 11)
    predicted = 87.5
    Initial_Temp = 900


num_particles = len(energy)

num_nuclei = len(energy[energy > 0])
num_electrons = len(energy[energy < 0])
dimensions = 3

print(f"Choose an integer initial temperature in kelvin. Default for {partname} is {Initial_Temp}")
Initial_Temp = int(input())

print(f"Simulate molecule for how many times? Default is 15.")
times = int(input())

start = time.time()

Temp = Initial_Temp

def variablegraph(Temps, p_accepts):

    m, b = np.polyfit(Temps, p_accepts, 1)
    x = np.array(Temps)
    y_fit = m * x + b

    plt.figure()
    plt.scatter(Temps, p_accepts, color='red')
    plt.plot(Temps, y_fit, color='blue')
    plt.title('p_accept with poltfit')
    plt.xlabel('Temp')
    plt.ylabel('p_accept')

    plt.show()


def graph(positions, energy_list,
          title="3D Distribution by Charge",
          size_base=4, size_scale=2):
    # ensure numpy arrays
    global partname
    
    path = rf"C:/Users/{os.getlogin()}/Desktop/Graphs/{partname}/{title}.html"
    
    pos = np.asarray(positions)
    charges = np.asarray(energy_list)

    # get unique charges sorted: largest positive first, then largest negative
    unique_charges = np.unique(charges)[::-1]

    # pick a color palette for positives and negatives
    pos_colors = ["red", "orange", "magenta", "gold"]
    neg_colors = ["blue", "green", "cyan", "lightblue"]
    pos_idx = neg_idx = 0

    traces = []
    for q in unique_charges:
        idx = np.where(charges == q)[0]

        # choose a color
        if q > 0:
            color = pos_colors[pos_idx % len(pos_colors)]
            pos_idx += 1
        else:
            color = neg_colors[neg_idx % len(neg_colors)]
            neg_idx += 1

        # size proportional to |charge|/e
        magnitude = abs(q) / elementary_charge
        size = size_base + size_scale * magnitude

        # name for legend
        sign = "+" if q > 0 else "−"
        name = f"{sign}{int(magnitude)} e"
        # pluralize:
        if magnitude != 1:
            name += "s"
        kind = "Proton" if q > 0 else "Electron"
        name = name.replace("e", f" e {kind}")

        traces.append(go.Scatter3d(
            x=pos[idx, 0], y=pos[idx, 1], z=pos[idx, 2],
            mode='markers',
            marker=dict(size=size, color=color),
            name=name
        ))

    fig = go.Figure(data=traces)
    fig.update_layout(
        title=title,
        scene=dict(
            xaxis_title='x (m)',
            yaxis_title='y (m)',
            zaxis_title='z (m)'
        )
    )

    folder = os.path.dirname(path)

    os.makedirs(folder, exist_ok=True)

    fig.write_html(path, auto_open=False)

import itertools
import numpy as np

def compute_all_bond_angles(positions, num_nuclei, idx):
    """
    Given:
      positions: an (N×3) array of coordinates for N nuclei+electrons,
      num_nuclei: how many of those are nuclei (the rest are electrons).
    Returns:
      A list of every angle (in °) between any two peripheral nuclei as seen
      from the central nucleus at index 0.
    """
    center = positions[0]
    angles = []
    # loop over all unique pairs of peripheral nuclei 1..num_nuclei-1
    for i, j in itertools.combinations(range(1, num_nuclei), 2):
        v1 = positions[i] - center
        v2 = positions[j] - center
        # your existing helper, returns radians
        theta = angle_between(v1, v2)
        angles.append(theta * 180/np.pi)
        
    global partname
    path = rf"C:/Users/{os.getlogin()}/Desktop/Graphs/{partname}/bond_angles #{idx}.txt"
    folder = os.path.dirname(path)

    os.makedirs(folder, exist_ok=True)
    
    np.savetxt(path, np.array(angles), 
               header="bond_angle_degrees", 
               comments="", 
               delimiter=",")


def unit_vector(vector):
    """ Returns the unit vector of the vector.  """
    return vector / np.linalg.norm(vector)


def angle_between(v1, v2):
    """ Returns the angle in radians between vectors 'v1' and 'v2'::

            >>> angle_between((1, 0, 0), (0, 1, 0))
            1.5707963267948966
            >>> angle_between((1, 0, 0), (1, 0, 0))
            0.0
            >>> angle_between((1, 0, 0), (-1, 0, 0))
            3.141592653589793
    """
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))


def random_position():

    dL = np.pow(10, np.random.uniform(np.log10(1e-14),
                np.log10(1e-11))) * Temp/Initial_Temp

    u = np.random.normal(size=dimensions)
    u /= np.linalg.norm(u)

    return dL * u


def get_potential(get_pot_parti):
    get_potential_pot = 0

    for k in range(len(get_pot_parti)):
        for j in range(k+1, len(get_pot_parti)):

            distance = np.linalg.norm(get_pot_parti[k]-get_pot_parti[j])

            if (distance < 1e-13):
                return (np.inf)

            get_potential_pot += (energy[k]*energy[j]) / \
                (4*np.pi*epsilon_0*distance)

    return (get_potential_pot)


def add_remove_contri(contri_parti, contri_row):

    potential_difference = 0

    for r in range(len(contri_parti)):

        if (r == contri_row):
            continue

        distance = np.linalg.norm(contri_parti[r]-contri_parti[contri_row])

        if (distance < 1e-13):
            return (np.inf)

        potential_difference += (energy[r]*energy[contri_row]) / \
            (4*np.pi*epsilon_0*distance)

    return potential_difference


def move_particle(move_row, move_parti, move_pot):

    trial_parti = np.copy(move_parti)
    trial_pot = move_pot

    trial_pot -= add_remove_contri(np.copy(trial_parti), move_row)

    trial_parti[move_row] += random_position()
    trial_parti[move_row] = np.clip(trial_parti[move_row], -5e-11, 5e-11)

    trial_pot += add_remove_contri(np.copy(trial_parti), move_row)

    if (np.isinf(trial_pot)):
        return (move_pot, move_parti, True)

    return (trial_pot, trial_parti, False)

def random_particle():
    Random_charge = np.random.randint(1,(np.sum(abs(energy))/elementary_charge)+1)
    
    energy_counter = 0
    for row in range(len(energy)):
        energy_counter += abs(energy[row])/elementary_charge
        if (energy_counter >= Random_charge):
            return row
        

p_accepts = []
Temps = []


def main():

    best_potential = np.inf
    global Temp
    Temp = Initial_Temp
    number = 0

    for _ in range(1000):

        particles = np.random.uniform(-10, 10,
                                      size=(num_particles, dimensions)) / 1e12

        particles[0] = np.array([0, 0, 0])

        potential = get_potential(particles)

        if potential < best_potential:
            best_potential = potential
            initial_distr = particles.copy()

    best_distr = initial_distr.copy()
    global ang
    ang = np.array([])
    Particle_iterations = 0

    boo = False

    while (Temp > 5):

        Row = random_particle()
        moves_since_change = 0

        ang = np.append(ang, angle_between(
            best_distr[2]-best_distr[0], best_distr[1]-best_distr[0]) / pi * 180)

        if Particle_iterations % num_particles == 0 and Particle_iterations != 0:
            Temp = Temp*0.9
            boo = True

        while (moves_since_change < threshold):
            potential, particles, rejected = move_particle(
                Row, best_distr.copy(), best_potential)

            if (rejected):
                moves_since_change += 1
                continue

            delta = potential - best_potential

            ratio = -delta / (Boltzmann * Temp)

            
            if (delta < 0):
                best_potential = potential
                best_distr = particles.copy()
                moves_since_change = 0

            elif (np.random.uniform() < np.exp(min(0, ratio)) and delta != 0):
                best_potential = potential
                best_distr = particles.copy()
                moves_since_change = 0

                if (boo):
                    numbers.append(number)
                    number = 0
                    boo = False
                    Temps.append(Temp)
                    print(len(best_distr), Temp)
                number += 1

            else:
                moves_since_change += 1

        best_potential = get_potential(best_distr)
        Particle_iterations += 1

    print(f"Final angle: {ang[-1]}")

    return (ang[-1], best_potential, best_distr)


final_distr = np.zeros((num_particles, dimensions))

total_angle = []
total_potential = []
distrs = []
numbers = []

threshold = 4

for run_idx in range(times):
    print(f"Run #{run_idx + 1}")

    angle, pot, distr = main()
    if len(distr) != num_particles:
        print("!!! Error: Distribution length mismatch !!!")

    total_angle.append(angle)
    total_potential.append(pot)
    distrs.append(distr)
    
    if(angle <= predicted + 20 and angle >= predicted - 20):
        all_angles = compute_all_bond_angles(distr, num_nuclei, run_idx + 1)
        graph(distr, energy,
              title=f"{partname}#{run_idx + 1} (Potential = {pot:.3e} J, Angle = {angle:.3f}°)")

best_idx = int(np.argmin(total_potential))
best_pot = total_potential[best_idx]
best_angle = total_angle[best_idx]

print(f"Least potential found in run #{best_idx + 1}: {best_pot}")
print(f"Angle for best run: {best_angle}\u00b0")
print(f"average angle: {np.mean(total_angle)}\u00b0")


all_angles = compute_all_bond_angles(distrs[best_idx], num_nuclei, best_idx + 1)

graph(
    distrs[best_idx],
    energy,
    title=f"{partname}#{best_idx + 1} (Least Potential = {best_pot:.3e} J, Angle = {best_angle:.3f}°)",
)

print ('{0:.2f} seconds elapsed.'.format(time.time()-start))
print ('Results are on your desktop. Look for a folder called "Graphs"')
